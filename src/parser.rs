extern crate pest;

use pest::error::Error;
use pest::iterators::Pairs;
use pest::pratt_parser::PrattParser;
use pest::Parser;
use pest_derive::Parser;

// Common Pratt-parser for correct processing of operator
// precedence and associativity not expressed in a grammar.
lazy_static::lazy_static! {
    static ref PRATT_PARSER: PrattParser<Rule> = {
        use pest::pratt_parser::{Assoc, Op};

        // define operation precedence from lowest to highest
        PrattParser::new()
            .op(Op::infix(Rule::or, Assoc::Left))
            .op(Op::infix(Rule::and, Assoc::Left))
            .op(Op::prefix(Rule::not))
    };
}

// Boolean expression parser autogenerated from grammar file.
#[derive(Parser)]
#[grammar = "grammar.pest"]
struct LogicParser;

// Parse string with logical expression into AST.
pub fn parse(expr: &str) -> Result<Expression, Error<Rule>> {
    // Raw parsing result, used as a source for Pratt parser.
    let mut pairs = LogicParser::parse(Rule::logexpr, expr)?;

    // starting from the inner of expr
    Ok(parse_expr(pairs.next().unwrap().into_inner()))
}

// Transform plain grammar-level tree into proper AST.
fn parse_expr(pairs: Pairs<Rule>) -> Expression {
    PRATT_PARSER
        .map_primary(|primary| match primary.as_rule() {
            Rule::var => Expression::Var(primary.as_str().to_string()),
            Rule::expr => parse_expr(primary.into_inner()), // from "(" ~ expr ~ ")"
            _ => unreachable!(),
        })
        .map_prefix(|op, rhs| match op.as_rule() {
            Rule::not => Expression::Not(Box::new(rhs)),
            _ => unreachable!(),
        })
        .map_infix(|lhs, op, rhs| match op.as_rule() {
            Rule::and => Expression::And(Box::new(lhs), Box::new(rhs)),
            Rule::or => Expression::Or(Box::new(lhs), Box::new(rhs)),
            _ => unreachable!(),
        })
        .parse(pairs)
}

#[derive(Debug, PartialEq)]
pub enum Expression {
    Var(String),
    Not(Box<Expression>),
    Or(Box<Expression>, Box<Expression>),
    And(Box<Expression>, Box<Expression>),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_expressions() {
        let expr = "a | b & !c";
        let res = parse(expr).unwrap();
        assert_eq!(
            res,
            Expression::Or(
                Box::new(Expression::Var("a".to_string())),
                Box::new(Expression::And(
                    Box::new(Expression::Var("b".to_string())),
                    Box::new(Expression::Not(Box::new(Expression::Var("c".to_string())))),
                )),
            )
        )
    }

    #[test]
    fn single_variable() {
        let expr = "a345_bc";
        let res = parse(expr).unwrap();
        assert_eq!(res, Expression::Var("a345_bc".to_string()));
    }

    #[test]
    fn sloppy_formatting() {
        let expr = "\n\t  a  \t| \tb &\n!  c  \n ";
        let res = parse(expr).unwrap();
        assert_eq!(
            res,
            Expression::Or(
                Box::new(Expression::Var("a".to_string())),
                Box::new(Expression::And(
                    Box::new(Expression::Var("b".to_string())),
                    Box::new(Expression::Not(Box::new(Expression::Var("c".to_string())))),
                )),
            )
        )
    }

    #[test]
    fn parenthesis() {
        let expr = "(![12vv + ([(ds_1)])] & ([a | !b]))";
        let res = parse(expr).unwrap();
        assert_eq!(
            res,
            Expression::And(
                Box::new(Expression::Not(Box::new(Expression::Or(
                    Box::new(Expression::Var("12vv".to_string())),
                    Box::new(Expression::Var("ds_1".to_string()))
                )))),
                Box::new(Expression::Or(
                    Box::new(Expression::Var("a".to_string())),
                    Box::new(Expression::Not(Box::new(Expression::Var("b".to_string()))))
                ))
            )
        )
    }
}
