extern crate pest;

use pest::Parser;
use pest::iterators::Pairs;
use pest::pratt_parser::{PrattParser, Assoc, Op};
use pest_derive::Parser;

// Boolean expression parser autogenerated from grammar file.
#[derive(Parser)]
#[grammar = "grammar.pest"]
struct LogicParser;

pub fn try_it(test_str: &str) {
    // Raw parsing result, used as a source for Pratt parser.
    let pairs = LogicParser::parse(Rule::logexpr, test_str).expect("WTF?");

    // use Pratt parser to get operator precedence correctly
    // (precedence depends on enumeration order)
    let pratt = PrattParser::new()
        .op(Op::infix(Rule::or, Assoc::Left))
        .op(Op::infix(Rule::and, Assoc::Left))
        .op(Op::prefix(Rule::not));

    let res = parse_expr(pairs, &pratt);
    println!("Result: {:#?}", res);
}

fn parse_expr<'a>(pairs: Pairs<'a, Rule>, pratt: &PrattParser<Rule>) -> String {
    pratt
        .map_primary(|primary| match primary.as_rule() {
            Rule::var  => primary.as_str().to_owned(),
            Rule::expr => parse_expr(primary.into_inner(), pratt), // from "(" ~ expr ~ ")"
            Rule::logexpr => primary.as_str().to_owned(), // terminal state
            _          => unreachable!(),
        })
        .map_prefix(|op, rhs| match op.as_rule() {
            Rule::not  => format!("NOT {}", rhs),
            _          => unreachable!(),
        })
        .map_infix(|lhs, op, rhs| match op.as_rule() {
            Rule::and  => format!("{} AND {}", lhs, rhs),
            Rule::or   => format!("{} OR {}", lhs, rhs),
            _          => unreachable!(),
        })
        .parse(pairs)
}


#[derive(Debug, PartialEq, Clone)]
pub enum Token {
    Or,
    And,
    Not,
    ParenLeft,
    ParenRight,
    Term(String),
}

// Part 1: lexing
pub fn tokenize(_input: &str) -> Result<Vec<Token>, &str> {
    todo!("tokenize input expression");
}

// Part 2: parsing
// TODO

// Part 3: constructing AST
// TODO
